#summary The trace-event file format

At its core, a trace event file is just an array of events, dumped into a file in
JSON. trace-viewer recognizes two representations of this array:
  # the JSON-stringified array
  # a JSON object with a member "traceEvents" containing the actual events.

The object-wrapped format is:
{{{
{
  "traceEvents": [event1,event2,...]
  ... any metadata you want... will be ignored.
}
}}}

The array format is:
{{{
[event1,event2,...]
}}}

The closing ] is optional in the array format. E.g. the following is valid:
{{{
[event1,event2,
}}}

This is done to support tracing systems that cannot cleanly finish writing the
trace, e.g. during exit.


=Trace events= 
Events are of the following format:
{{{
{
  "ph": "B" | "E" | "I" | "M"
}
}}}

=Time units=
Time units are given in *microseconds*

=Begin/End events=
B and E type events correspond to the beginning and end of work
on a given thread:
{{{
{
  "ph": "B",
  "ts": 1234523.3, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "MyFunction", // name of function that began
  "args": {}  // any arguments associated with the function 
},
{
  "ph": "E",
  "ts": 1234600, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "MyFunction", // name of function that ended. can be optional
}
}}}

B and E events can nest, allowing you to capture function calling behavior on a
thread. For example, this trace is for function A that then calls function
Asub, where Asub takes 2.8us and A takes 3us:
{{{
  { ..., ts=1.0, tid=1, ph="B", name="A"},
  { ..., ts=1.1, tid=1, ph="B", name="Asub"},
  { ..., ts=3.9, tid=1, ph="E", name=""},
  { ..., ts=4.0, tid=1, ph="E", name=""},
}}}

Events must be sorted in timestamp order PER THREAD but can interleave
between different threads. E.g. you can have:
{{{
  { ..., ts=1.0, tid=1, ph="B", name="A"},
  { ..., ts=0.9, tid=2, ph="B", name="B"},
  { ..., ts=1.1, tid=1, ph="E", name=""},
  { ..., ts=4.0, tid=2, ph="E", name=""},
}}}

Sometimes, it is necessary to represent operations that are logically part of
a thread, but that occur out-of-band with the function calling stack. For this, see the async events, described below.

=Immediate Events=
I phase events correspond to instantaneous events on a thread. For example,
an out of memory condition:
{{{
{
  "ph": "I",
  "ts": 1234523.3, // in microseconds
  "pid": 2343, "tid": 2347,  // indicates event on process 2343 thread 2347
  "name": "OutOfMemory", // name of the event
  "args": {}  // any arguments associated with the event
}
}}}

=Async events=
S and F phase events are used to represent asynchronous operations, e.g frames in a game, network or async file I/O: S and F events can start and finish on different processes. The key is for both events to agree upon a common id, which can be used to associate the events during load time.

{{{
{
  "ph": "S",
  "pid": 2343,
  "tid": 2347,
  "ts": 1234523.3, // in microseconds
  "id": 0x100,
  "name": "async_read",
  "args": { "name" : "~/.bashrc" }
},
{
  "ph": "F",
  "pid": 2342,
  "tid": 2343, // note, different thread
  "ts": 1235523.3, // in microseconds
  "id": 0x100,
  "name": "async_read",
}
}}}

Async events can have steps in them. For example, you might begin to load from a server, then get the headers back, then finally be done. To represent that 'intermediate' step, we have the 'T' phase:
{
  "ph": "T",
  "pid": 2342,
  "tid": 2343, // note, different thread
  "ts": 1235000.0, // in microseconds
  "id": 0x100,
  "name": "headers_complete",
}
In the UI, this would show up as a single large async_read bar, with individual steps inside it for the headers-complete stage.

=Counters=
C phase events are used for tracking a value or multiple values over time. This tracks a value moving from 0, to 10, back to zero, over a 20 microsecond time period:
{{{
    {name: 'ctr', args: {'value': 0}, pid: 1, ts: 0, cat: 'foo', tid: 1, ph: 'C'},
    {name: 'ctr', args: {'value': 10}, pid: 1, ts: 10, cat: 'foo', tid: 1, ph: 'C'},
    {name: 'ctr', args: {'value': 0}, pid: 1, ts: 20, cat: 'foo', tid: 1, ph: 'C'}
}}}

Counters can have multiple values per sample. When that happens, they are considered to be "part of a whole." E.g.
{{{
    {name: 'ctr', args: {'value1': 0, 'value2': 7}, pid: 1, ts: 0, cat: 'foo', tid: 1, ph: 'C'},
    {name: 'ctr', args: {'value1': 10, 'value2': 4}, pid: 1, ts: 10, cat: 'foo', tid: 1, ph: 'C'},
    {name: 'ctr', args: {'value1': 0, 'value2': 1 }, pid: 1, ts: 20, cat: 'foo', tid: 1, ph: 'C'}
}}}
In this case, value1 and value2 will be shown as a stacked area chart in the UI.

=Objects=
Objects are a building block to track complex data structures in traces. Since traces go for long periods of time, the formative concept for this is a way to identify objects in a time varying way. To identify an object, you need to give it an id, usually its pointer, e.g. id: "0x1000". But, in a long running trace, or just a trace with a clever allocator, a raw pointer 0x1000 might refers to two different objects at two different points in time.

In trace_event, we think in terms of object instances. E.g. in C++, given class Foo , new Foo() at 0x1000 is an instance of foo. Tracing has opcodes to indicate when an object instance comes into being,  with a given identifier, and when it dies. This sequence of events shows MyObject 0x1000 that is alive from ts=0 to ts=20:
{{{
    {id: "0x1000", name: 'MyObject', pid: 1, ts: 0, cat: 'foo', tid: 1, ph: 'N'},
    {id: "0x1000", name: 'MyObject', pid: 1, ts: 20, cat: 'foo', tid: 1, ph: 'D'}
}}}

Objects, like slices, obey the convention of the start time being inclusive, the deletion time being exclusive. So, if we also had this set of events in addition to the MyObject events:
{{{
    {id: "0x1000", name: 'MyOtherObject', pid: 1, ts: 20, cat: 'foo', tid: 1, ph: 'N'},
    {id: "0x1000", name: 'MyOtherObject', pid: 1, ts: 25, cat: 'foo', tid: 1, ph: 'D'}
}}}

Then, a ref at ts=20 points at MyOtherObject instance, not MyObject.

=Object Snapshots=
The object instance commands, you will notice, do not have args: {} fields. Meaning, you cannot associate
data with object instances. This may seem silly, until you think about how traces are time varying. In software, very few things stay constant for their lifetime --- rather they vary over time. But, you can dump it into a trace at a given instant in time. This is called a snapshot:
{{{
    {id: "0x1000", name: 'MyObject', args: {snapshot: {...}}, pid: 1, ts: 10, cat: 'foo', tid: 1, ph: 'O'},
}}}
The ellipsis inside the snapshot field can be anything you want, as much as you want. You can, for instance, put a complete dump of your rendering system into the snapshot.

=Object References=
Objects get useful when you start getting them to point at each other. In trace event, any event that takes args, e.g. slice, async slice, snapshot, will be scanned after load for fields of the form:
{{{
   fieldName: {id_ref: id_value}
}}}
For example, like this slice:
{{{
    {id: "0x1000", name: 'SliceA', pid: 1, ts: 10, cat: 'foo', tid: 1, ph: 'B', args: { obj: {id_ref: "0x1000"}}},
    {id: "0x1000", name: 'SliceA', pid: 1, ts: 15, cat: 'foo', tid: 1, ph: 'E'}
}}}
The importing system will look for an id that is alive at ts=10, then look for a snapshot that was taken at ts=10, and replace the {id_ref...} object with the actual object snapshot at runtime.

If an object is created at ts=0, and has snapshots at 10, 20, and is deleted at 30, then refs bind in the following way:
{{{
   ref at ts=5   -> snapshot from ts=10
   ref at ts=15 -> snapshot at ts=10
   ref at ts=20 -> snapshot at ts=20
   ref at ts=25 -> snapshot at ts=20
}}}

=Metdata=
M phase events are used to associate metadata with events. For example,
to give a thread a name:
{{{
{
  "ph": "M",
  "pid": 2343,
  "tid": 2347,
  "name": "thread_name",
  "args": { "name" : "RendererThread" }
}
}}}