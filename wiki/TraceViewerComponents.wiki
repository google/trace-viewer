#summary How to write trace viewer components

The trace viewer component model, tvcm, is a simplified component model. It uses a closure-inspired design pattern: javascript modules, with dependencies requires. It has a python-based build system that is used to host a local development server as well as flatten/vulcanize the resulting code.

=Principles=
We care the most about the public interface of the component. Make sure that it is minimal, and sealed. Users of the component should never reach inside the component, ever, and internal implementation details of the component should never be made visible to external users.

tldr, never ever ever use querySelector. Mutate/access html attributes/childlist elements directly only iff the object is designed for it, e.g. ui/list_view.


=Events and Properties=
  # Properties should be settable in any order
  # Properties can be backed by a member variable of the same name, e.g. set foo() -> this.foo`_`. If their use is super trivial, e.g. just passthrough to some other property, then its okay to not store it as a member variable. If you call bind(this) on the properties, the member variable is still called this.foo`_`.
  # Properties should come with getters, unless it is non-sensical. If you don't "need it" you should still write it.

Components should dispatch events for changes it makes to to publically visible attributes, if it makes sense. Not all properties need to dispatch change events. Internal only properties should not dispatch public events, if at all possible.

Properties should be limited to the absolute minimum. Properties that exist simply to propagate change events between internal parts of a component should be suffixed with an underscore, eg myInternalProperty`_`.

=Property declaration order=
  # `__`proto`__`
  # decorate() 
  # getter/setter pairs
  # public methods
  # private methods, post-pended with underbar`_`

=Component boundaries, scoping=
Never reach outside your class into another component, using querySelector/querySelectorAll. Add properties, methods to the component you're interacting.

CSS should be localized, whenever possible.

A component should work regardless of its parent. If there is specific behavior defined between a pair of components, then the "owner"/"creator" of the components should define that relationship, not the individual components.

tldr, most of your css should of the form: "component-name", or "component > direct-component-child". Dont go poking deeper unless you have a darn good reason.

 
=Putting it together=
This is a basic span that has a red background color and a label that we can set:

{{{
tvcm.require('red_span.css');

var RedSpan = tvcm.ui.define('red-span');
RedSpan.prototype = {
  __proto__: HTMLUnknownElement,
  decorate: function() {
    this.spanLabel_ = undefined;
  },

  get spanLabel() {
    return this.spanLabel_;
  },
  set spanLabel(spanLabel) {
    this.spanLabel_ = spanLabel;
    this.textContents = "span: " + this.spanLabel_;
  }
}
}}}

Here we cache the spanLabel`_` value as a property because the assignment to textContents is destructive.

The css is
{{{
red-span { // prefer styling using the tag name
  display: span;
  background-color: red;
}
}}}

=Multiple fields=
Sometimes, you'll have a few fields whose combined value defines the component. We typically use an updateContents`_` design pattern for this:

{{{
  decorate: function() {
    this.prefix_ = 'span: '; // we prefer to set defaults here, not on the prototype.
    this.spanLabel_ = undefined; // and we set them even when they're undefined.
  },

  get prefix() {
    return this.prefix_;
  },
  set prefix(prefix) {
    this.prefix_ = prefix;
    this.updateContents_();
  }

  get spanLabel() {
    return this.spanLabel_;
  },
  set spanLabel(value) {
    this.spanLabel_ = spanLabel;
    this.updateContents_();
  }
  updateContents_: function() {
    this.textContents = this.prefix_ + this.spanLabel_;
  }
}}}

=Graceful failure of missing properties=
If a property can be unset, then updateContents`_` should fail without exploding.

If a property has invalid values, the setter should raise an exception before letting the value be assigned.


=Complex update calculations=
Sometimes the repeated calling of updateContents`_` is too costly. Two options:
  # add a setter for the pair of properties that are often set together. E.g., setPrefixAndSpanLabel(span, spanLabel), or
  # scheduleUpdateContents`_`() from the setters and have the scheduler use base.requestAnimationFrameInThisFrameIfPossible to call the actual updateContents`_` function.