<!DOCTYPE html>
<!--
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/analysis/analysis_results.html">
<link rel="import" href="/tracing/analysis/analyze_counters.html">
<link rel="import" href="/tracing/analysis/analyze_objects.html">
<link rel="import" href="/tracing/analysis/analyze_slices.html">
<link rel="import" href="/tracing/analysis/analyze_samples.html">
<link rel="import" href="/tracing/analysis/default_object_view.html">
<link rel="import" href="/tracing/analysis/object_instance_view.html">
<link rel="import" href="/tracing/analysis/object_snapshot_view.html">
<link rel="import" href="/tracing/analysis/slice_view.html">
<link rel="import" href="/tracing/analysis/tab_view.html">
<link rel="import" href="/tracing/trace_model/counter_sample.html">
<link rel="import" href="/tracing/trace_model/flow_event.html">
<link rel="import" href="/tracing/trace_model/instant_event.html">
<link rel="import" href="/tracing/trace_model/object_instance.html">
<link rel="import" href="/tracing/trace_model/object_snapshot.html">
<link rel="import" href="/tracing/trace_model/slice.html">

<!--
@fileoverview A component used to display an analysis of a selection,
using custom elements specialized for different event types.
-->
<polymer-element name="tracing-analysis-view"
    constructor="TracingAnalysisView">
  <template>
    <style>
      :host {
        background-color: white;
        display: flex;
        flex-direction: column;
        height: 275px;
        overflow: auto;
      }

      :host(.tall-mode) {
        height: 525px;
      }

      ::content > * {
        flex: 1 0 auto;
      }
    </style>
    <content></content>
  </template>
  <script>
  'use strict';
  (function() {

    /*
     * Subview type registry: individual subviews call this registration
     * function when they are created. We then consult all the registered
     * subview types when handling a selection.
     */
    var subViewTypes = [];
    tracing.registerAnalysisSubViewType = function(
        importance, supportsSelectionPredicate, viewConstructor) {
      subViewTypes.push({
        importance: importance,
        supportsSelectionPredicate: supportsSelectionPredicate,
        viewConstructor: viewConstructor
      });
    }

    /**
     * Utility function used to convert camelCase to Title Case.
     */
    function convertEventTypeToTabName(eventType) {
      var result = eventType.replace(/[A-Z]/g, ' $&');
      result = result.charAt(0).toUpperCase() + result.slice(1);
      return result;
    }

    Polymer({
      ready: function() {
        this.currentView_ = undefined;
        this.currentSelection_ = undefined;
      },

      set tallMode(value) {
        if (value)
          this.classList.add('tall-mode');
        else
          this.classList.remove('tall-mode');
      },

      get tallMode() {
        return this.classList.contains('tall-mode');
      },

      get currentView() {
        return this.currentView_;
      },

      get selection() {
        return this.currentSelection_;
      },

      set selection(selection) {
        this.processSelection_(selection);
      },

      processSelection_: function(selection) {
        this.tallMode = false;
        this.textContent = '';

        var eventsByType = selection.getEventsOrganizedByType(true);

        var categoriesToAnalyze = tvcm.dictionaryLength(eventsByType)

        var subViewsParent;
        var usingTabs = false;
        // If we have to analyze more than one category, we use a tab view
        // for displaying them.
        if (categoriesToAnalyze > 1) {
          usingTabs = true;
          subViewsParent = new TracingAnalysisTabView();
          this.appendChild(subViewsParent);
        } else {
          subViewsParent = this;
        }

        for (var eventType in eventsByType) {
          var currentEvents = eventsByType[eventType];
          var subView = undefined;
          // If there is only one event of this type, try to get a custom
          // view for it.
          if (currentEvents.length === 1) {
            subView = this.getEventCustomView_(currentEvents[0]);
            // If found, add it to the subViewsParent and have the
            // custom view model the event.
            if (subView) {
              subViewsParent.appendChild(subView)
              subView.modelEvent = currentEvents[0];
            }
          }

          // If no custom view is found, analyze it using the standard
          // analysis system.
          if (!subView) {
            subView = this.findSubViewForEventsOfSingleType_(
                          eventsByType[eventType]);
            subViewsParent.appendChild(subView);
            subView.selection = eventsByType[eventType];
          }

          this.tallMode = this.tallMode || subView.requiresTallView;
          if (usingTabs) {
            var tabLabel = convertEventTypeToTabName(eventType);
            subView.tabLabel = tabLabel;
          }
        }

        if (usingTabs) {
          subViewsParent.selectedTab = subViewsParent.firstChild;
          this.currentView_ = subViewsParent
        } else {
          this.currentView_ = this.firstChild;
        }
      },

      /**
       * This function returns an instantiated custom view for the event
       * passed as a parameter.
       *
       * @param {TraceEvent} event The event for witch to find the custom view.
       *
       * @return The custom view, displaying the event. 'undefined' if no
       *         custom view is found.
       */
      getEventCustomView_: function(event) {
        var typeName;
        var viewBaseType;
        var defaultViewType;
        if (event instanceof tracing.trace_model.ObjectSnapshot) {
          typeName = event.objectInstance.typeName;
          viewBaseType = tracing.analysis.ObjectSnapshotView;
          defaultViewType = tracing.analysis.DefaultObjectSnapshotView;
        } else if (event instanceof tracing.trace_model.ObjectInstance) {
          typeName = event.typeName;
          viewBaseType = tracing.analysis.ObjectInstanceView;
          defaultViewType = tracing.analysis.DefaultObjectInstanceView;
        } else if (event instanceof tracing.trace_model.Slice) {
          typeName = event.analysisTypeName;
          viewBaseType = tracing.analysis.SliceView;
          defaultViewType = undefined;
        } else {
          // No event custom view defined for this particular event.
          return undefined;
        }

        var customViewInfo = viewBaseType.getViewInfo(typeName);

        var viewConstructor = customViewInfo ?
            customViewInfo.constructor : defaultViewType;

        // Some view types do not have default views. In those cases, we fall
        // back to the standard analysis system.
        if (!viewConstructor)
          return undefined;

        var resultView = new viewConstructor();

        return resultView;
      },

      findSubViewForEventsOfSingleType_: function(selection) {
        var supportedSubViewTypes = subViewTypes.filter(function(subViewTypes) {
          return subViewTypes.supportsSelectionPredicate(selection);
        });

        if (supportedSubViewTypes.length == 0)
          throw new Error('Received events that could not be analyzed!');

        // Pick the most important registered type handler.
        supportedSubViewTypes.sort(function(x,y) {
          return y.importance - x.importance;
        });
        var subViewType = supportedSubViewTypes[0];

        return new subViewType.viewConstructor();
      }
    });
  })();
  </script>
</polymer-element>
