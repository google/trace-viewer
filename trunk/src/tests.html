<!DOCTYPE html>
<html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<head>
<title>All Tracing Tests</title>
<script>
  G_allTests = [
    'category_filter_dialog_test.html',
    'filter_test.html',
    'find_control_test.html',
    'overlay_test.html',
    'profiling_view_test.html',
    'range_test.html',
    'selection_test.html',
    'settings_test.html',
    'sorted_array_utils_test.html',
    'timeline_analysis_view_test.html',
    'timeline_test.html',
    'timeline_view_test.html',
    'timeline_viewport_test.html',
    'ui_test.html',
    'unittest_test.html',

    'model_test.html',
    'model/async_slice_group_test.html',
    'model/counter_test.html',
    'model/cpu_test.html',
    'model/object_collection_test.html',
    'model/object_instance_test.html',
    'model/process_base_test.html',
    'model/process_test.html',
    'model/slice_group_test.html',
    'model/thread_test.html',
    'model/time_to_object_instance_map_test.html',

    'importer/linux_perf_importer_test.html',
    'importer/linux_perf/android_parser_test.html',
    'importer/linux_perf/bus_parser_test.html',
    'importer/linux_perf/clock_parser_test.html',
    'importer/linux_perf/cpufreq_parser_test.html',
    'importer/linux_perf/disk_parser_test.html',
    'importer/linux_perf/drm_parser_test.html',
    'importer/linux_perf/exynos_parser_test.html',
    'importer/linux_perf/gesture_parser_test.html',
    'importer/linux_perf/i915_parser_test.html',
    'importer/linux_perf/kfunc_parser_test.html',
    'importer/linux_perf/mali_parser_test.html',
    'importer/linux_perf/power_parser_test.html',
    'importer/linux_perf/sched_parser_test.html',
    'importer/linux_perf/workqueue_parser_test.html',
    'importer/timeline_stream_importer_test.html',
    'importer/trace_event_importer_test.html',
    'importer/v8_log_importer_test.html',

    'tracks/async_slice_group_track_test.html',
    'tracks/cpu_track_test.html',
    'tracks/counter_track_test.html',
    'tracks/object_instance_track_test.html',
    'tracks/slice_group_track_test.html',
    'tracks/slice_track_test.html',
    'tracks/thread_track_test.html',
    'tracks/ruler_track_test.html',

    'analysis/counter_selection_analysis_test.html',
    'analysis/selection_analysis_test.html',
    'analysis/slice_selection_analysis_test.html',
    'analysis/slice_group_selection_analysis_test.html',
    'analysis/single_counter_selection_analysis_test.html',
    'analysis/single_slice_selection_analysis_test.html',
  ];
</script>
<style>
  h1 {
      font-family: sans-serif;
      font-size: 18pt;
  }
</style>
<script src="base.js"></script>
<script>
  base.require('unittest');
</script>
</head>
<body>
  <h1>Trace-Viewer Tests</h3>

  <div class="unittest">Interactive tests: <a href="interactive_tests.html" class="unittest-error-link">Run manually</a></div>
  <br>

  <script>
  function IFrameTestCase(test) {
    var testCaseEl = new unittest.TestCaseElement(test, test, true);
    testCaseEl.__proto__ = IFrameTestCase.prototype;
    testCaseEl.decorate(test);
    return testCaseEl;
  }

  IFrameTestCase.prototype = {
    __proto__: unittest.TestCaseElement.prototype,

    decorate: function(test) {
      this.status = 'READY';
      this.iframe = document.createElement('iframe');
      this.iframe.src = test;
      this.iframe.style.position = 'fixed';
      this.iframe.style.visibility = 'hidden';
    },

    begin: function() {
      this.status = 'RUNNING';
      this.appendChild(this.iframe);
      this.iframe.contentWindow.addEventListener('error', function(msg, url, lineNumber) {
        if (iframe.contentWindow.G_testRunner)
          return false;

        if (iframe.contentWindow.errorsCaughtByTestHarness)
          return false;

        iframe.contentWindow.errorsCaughtByTestHarness = [
          {msg: msg, url: url, lineNumber: lineNumber}];
        return false;
      });
    },

    get done() {
      if (this.status == 'READY' ||
          this.status == 'RUNNING')
        return false;
      return true;
    },

    checkForDone: function() {
      var iframe = this.iframe;
      if (!iframe.contentWindow)
        return;

      if (iframe.contentWindow.errorsCaughtByTestHarness &&
        iframe.contentWindow.errorsCaughtByTestHarness.length) {
        this.status = 'FAILED'
        return;
      }

      if (!iframe.contentWindow.G_testRunner)
        return;

      var childRunner = iframe.contentWindow.G_testRunner;
      if (!childRunner.done)
        return;

      var stats = childRunner.computeResultStats();
      if (stats.numTestsRun && !stats.numTestsWithErrors)
        this.status = 'PASSED'
      else
        this.status = 'FAILED'
    }
  };

  function AsyncTestRunner() {
    var resultsEl = document.createElement('div');
    resultsEl.__proto__ = AsyncTestRunner.prototype
    resultsEl.decorate();
    return resultsEl;
  }

  AsyncTestRunner.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
      this.className = 'unittest';
      this.maxNumTestsToRunAtOnce_ = 1;
      this.processTestQueuesScheduled_ = false;
      this.readyTests_ = [];
      this.runningTests_ = [];
    },

    get maxNumTestsToRunAtOnce() {
      return this.maxNumTestsToRunAtOnce_;
    },

    set maxNumTestsToRunAtOnce(value) {
      this.maxNumTestsToRunAtOnce_ = value;
      processTestQueues_();
    },

    enqueueTests: function(tests) {
      for (var i = 0; i < tests.length; i++) {
        var test = new IFrameTestCase(tests[i]);
        if (test.done)
          throw new Error('Cannot enqueue test that is done.');
        this.readyTests_.push(test);
        this.appendChild(test);
      }
      if (this.readyTests_.length)
        this.scheduleProcessTestQueues_();
    },

    scheduleProcessTestQueues_: function() {
      if (this.processTestQueuesScheduled_)
        return;
      setTimeout(this.processTestQueues_.bind(this), 100);
      this.processTestQueuesScheduled_ = true;
    },

    processTestQueues_: function() {
      this.processTestQueuesScheduled_ = false;

      var stillRunningTests = [];
      this.runningTests_.forEach(function(test) {
        test.checkForDone();
        if (!test.done) {
          stillRunningTests.push(test);
          return;
        }
      }, this);
      this.runningTests_ = stillRunningTests;

      while (this.readyTests_.length > 0 &&
             this.runningTests_.length < this.maxNumTestsToRunAtOnce_) {
        var test = this.readyTests_.shift();
        test.begin();
        this.runningTests_.push(test);
      }

      if (!this.readyTests_.length && !this.runningTests_.length)
        this.onDone_();
      else
        this.scheduleProcessTestQueues_();
    },

    onDone_: function() {
      /* all tests are done */;
    },
  };

  document.addEventListener('DOMContentLoaded', function() {
    var runner = new AsyncTestRunner();
    document.body.appendChild(runner);
    runner.enqueueTests(G_allTests);
  });
  </script>
</body>
</html>
