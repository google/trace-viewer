<!DOCTYPE HTML>
<html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<head>
<title>TimelineView tests</title>
<script src="base.js"></script>
<style>
  .timeline-view {
    border: 1px solid black;
    margin: 10px;
    height: 350px;
  }
  .timeline-find-dialog {
    border: 1px solid black;
    margin: 10px;
  }
</style>
</head>
<body>
<script>
'use strict';

base.defineModule('timeline_view_test')
    .dependsOn('unittest',
               'test_utils',
               'timeline_view')
    .runAllTests(function() {

    var tests = {};
    /*
     * Just enough of the Timeline to support the tests below.
     */
    var FakeTimeline = base.ui.define('div');

    FakeTimeline.prototype = {
      __proto__: HTMLDivElement.prototype,

      decorate: function() {
        this.addAllObjectsMatchingFilterToSelectionReturnValue = [];

        this.selection = new tracing.TimelineSelection();
        this.keyHelp = "<keyHelp>";

        // Put some simple UI in for testing purposes.
        var noteEl = document.createElement('div');
        noteEl.textContent = "FakeTimeline:";
        this.appendChild(noteEl);

        this.statusEl_ = document.createElement('div');
        this.appendChild(this.statusEl_);
        this.refresh_();
      },

      refresh_: function() {
        var status;
        if (this.model)
          status = "model=set";
        else
          status = "model=undefined";
        this.statusEl_.textContent = status;
      },

      setSelectionAndMakeVisible: function(selection, zoomAllowed) {
        this.selection = selection;
      },

      addAllObjectsMatchingFilterToSelection: function(filter, selection) {
        var n = this.addAllObjectsMatchingFilterToSelectionReturnValue.length;
        for (var i = 0; i < n; i++)
          selection.push_(
              this.addAllObjectsMatchingFilterToSelectionReturnValue[i]);
      }
    };

    /*
     * This test just instantiates a TimelineView and adds it to the DOM
     * to help with non-unittest UI work.
     */
    tests.testInstantiateTimelineView = function() {
      var events = [];
      var num_tests = 50;
      var testIndex = 0;
      for(testIndex = 0; testIndex < num_tests; ++testIndex){
        var startTime = 500 + Math.random()*300;
        var endTime = startTime + Math.random()*300;
        events.push({name: 'a'+testIndex, args: {}, pid: testIndex, ts: startTime, cat: 'foo', tid: 53, ph: 'B'});
        events.push({name: 'a'+testIndex, args: {}, pid: testIndex, ts: endTime, cat: 'foo', tid: 53, ph: 'E'});
      }

      /*
       * Add a slice with the same title as one of the previous slices
       * to test the case where multiple of these are selected.
       */
        events.push({name: 'a49', args: {}, pid: testIndex, ts: startTime, cat: 'foo', tid: 53, ph: 'B'});
        events.push({name: 'a49', args: {}, pid: testIndex, ts: endTime, cat: 'foo', tid: 53, ph: 'E'});

      // Add a known problematic piece of data to test the import errors UI.
      events.push({ph: 'Z'});

      var model = new tracing.TimelineModel(events);
      var view = new tracing.TimelineView();
      view.style.height = '400px';
      view.model = model;
      view.tabIndex = 0;
      view.focusElement = view;

      var selection = new tracing.TimelineSelection();
      view.timeline.addAllObjectsMatchingFilterToSelection({matchSlice: function(){return true;}}, selection);
      view.timeline.selection = selection;

      document.body.appendChild(view);
    }

    /*
     * This test just instantiates a FindDialog and adds it to the DOM
     * to help with non-unittest UI work.
     */
    tests.testInstantiateTimelineFindControl = function() {
      var ctl = new tracing.TimelineFindControl();
      var didFindPrevious = false;
      var didFindNext = false;
      ctl.controller = {
        findNext: function() {
          didFindNext = true;
        },

        findPrevious: function() {
          didFindPrevious = true;
        },

        filterHits: [],

        currentHitIndex: 0,
      }
      document.body.appendChild(ctl);
      ctl.querySelector('input').focus();
      ctl.querySelector('input').blur();

      ctl.querySelector('.find-previous').click();
      assertTrue(didFindPrevious);
      ctl.querySelector('.find-next').click();
      assertTrue(didFindNext);
    }

    tests.testFindControllerNoTimeline = function() {
      var controller = new tracing.TimelineFindController();
      controller.findNext();
      controller.findPrevious();
    }

    tests.testFindControllerEmptyHit = function() {
      var timeline = new FakeTimeline();
      var controller = new tracing.TimelineFindController();
      controller.timeline = timeline;

      timeline.selection = new tracing.TimelineSelection();
      controller.findNext();
      assertArrayShallowEquals([], timeline.selection);
      controller.findPrevious();
      assertArrayShallowEquals([], timeline.selection);
    }

    tests.testFindControllerOneHit = function() {
      var timeline = new FakeTimeline();
      var controller = new tracing.TimelineFindController();
      controller.timeline = timeline;

      timeline.addAllObjectsMatchingFilterToSelectionReturnValue = [1];
      controller.findNext();
      assertArrayShallowEquals([1], timeline.selection);
      controller.findNext();
      assertArrayShallowEquals([1], timeline.selection);
      controller.findPrevious();
      assertArrayShallowEquals([1], timeline.selection);
    }

    tests.testFindControllerMultipleHits = function() {
      var timeline = new FakeTimeline();
      var controller = new tracing.TimelineFindController();
      controller.timeline = timeline;

      timeline.addAllObjectsMatchingFilterToSelectionReturnValue = [1,2,3];

      // Loop through hits then when we wrap, try moving backward.
      controller.findNext();
      assertArrayShallowEquals([1], timeline.selection);
      controller.findNext();
      assertArrayShallowEquals([2], timeline.selection);
      controller.findNext();
      assertArrayShallowEquals([3], timeline.selection);
      controller.findNext();
      assertArrayShallowEquals([1], timeline.selection);
      controller.findPrevious();
      assertArrayShallowEquals([3], timeline.selection);
      controller.findPrevious();
      assertArrayShallowEquals([2], timeline.selection);
    }

    tests.testFindControllerChangeFilterAfterNext = function() {
      var timeline = new FakeTimeline();
      var controller = new tracing.TimelineFindController();
      controller.timeline = timeline;

      timeline.addAllObjectsMatchingFilterToSelectionReturnValue = [1,2,3];

      // Loop through hits then when we wrap, try moving backward.
      controller.findNext();
      timeline.addAllObjectsMatchingFilterToSelectionReturnValue = [4];
      controller.filterText = "asdfsf";
      controller.findNext();
      assertArrayShallowEquals([4], timeline.selection);
    }

    tests.testFindControllerSelectsFirstItemImmediately = function() {
      var timeline = new FakeTimeline();
      var controller = new tracing.TimelineFindController();
      controller.timeline = timeline;
      timeline.addAllObjectsMatchingFilterToSelectionReturnValue = [1,2,3];
      controller.filterText = "asdfsf";
      assertArrayShallowEquals([1], timeline.selection);
      controller.findNext();
      assertArrayShallowEquals([2], timeline.selection);
    }

    tests.testFindControllerWithRealTimeline = function() {
      var model = new tracing.TimelineModel();
      var p1 = model.getOrCreateProcess(1);
      var t1 = p1.getOrCreateThread(1);
      t1.pushSlice(new tracing.TimelineThreadSlice('a', 0, 1, {}, 3));

      var timeline = new tracing.Timeline();
      timeline.model = model;

      var controller = new tracing.TimelineFindController();
      controller.timeline = timeline;

      // Test find with no filterText.
      controller.findNext();

      // Test find with filter txt.
      controller.filterText = 'a';
      controller.findNext();
      assertEquals(1, timeline.selection.length);
      assertEquals(t1.subRows[0][0], timeline.selection[0].slice);

      controller.filterText = 'xxx';
      controller.findNext();
      assertEquals(0, timeline.selection.length);
      controller.findNext();
      assertEquals(0, timeline.selection.length);
    }

    return tests;
});
</script>
</body>
</html>
