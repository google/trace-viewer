<!DOCTYPE HTML>
<html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<head i18n-values="dir:textdirection;">
<title>TimelineAnalysis tests</title>
<script src="base.js"></script>
<style>
  .timeline-view {
    border: 1px solid black;
    margin: 10px;
  }
  .timeline-find-dialog {
    border: 1px solid black;
    margin: 10px;
  }
</style>
</head>
<body>
  <script>
'use strict';

base.defineModule('timeline_analysis_test')
    .dependsOn('unittest',
               'test_utils',
               'timeline_model',
               'trace_event_importer',
               'timeline_analysis',
               'timeline'/* TODO(nduca): reduce dependency to selection and track */ )
    .runAllTests(function() {

    var tests = {};

    function createSelectionWithSingleSlice() {
      var events = [
        {name: 'b', args: {}, pid: 52, ts: 629, cat: 'foo', tid: 53, ph: 'B'},
        {name: 'b', args: {}, pid: 52, ts: 631, cat: 'foo', tid: 53, ph: 'E'},
      ];
      var model = new tracing.TimelineModel();
      model.importEvents(events);

      var t53track = new tracing.TimelineThreadTrack();
      t53track.thread = model.processes[52].threads[53];

      var selection = new tracing.TimelineSelection();
      t53track.addAllObjectsMatchingFilterToSelection(
        new tracing.TimelineFilter('b'), selection);
      assertEquals(1, selection.length);

      return selection;
    }

    function createSelectionWithTwoSlices() {
      var events = [
        {name: 'a', args: {}, pid: 52, ts: 520, cat: 'foo', tid: 53, ph: 'B'},
        {name: 'a', args: {}, pid: 52, ts: 560, cat: 'foo', tid: 53, ph: 'E'},
        {name: 'aa', args: {}, pid: 52, ts: 640, cat: 'foo', tid: 53, ph: 'B'},
        {name: 'aa', args: {}, pid: 52, ts: 700, cat: 'foo', tid: 53, ph: 'E'},
      ];
      var model = new tracing.TimelineModel();
      model.importEvents(events);

      var t53track = new tracing.TimelineThreadTrack();
      t53track.thread = model.processes[52].threads[53];

      var selection = new tracing.TimelineSelection();
      t53track.addAllObjectsMatchingFilterToSelection(
        new tracing.TimelineFilter('a'), selection);
      assertEquals(2, selection.length);

      return selection;
    }

    function createSelectionWithTwoSlicesSameTitle() {
      var events = [
        {name: 'c', args: {}, pid: 52, ts: 620, cat: 'foo', tid: 53, ph: 'B'},
        {name: 'c', args: {}, pid: 52, ts: 660, cat: 'foo', tid: 53, ph: 'E'},
        {name: 'c', args: {}, pid: 52, ts: 740, cat: 'foo', tid: 53, ph: 'B'},
        {name: 'c', args: {}, pid: 52, ts: 800, cat: 'foo', tid: 53, ph: 'E'},
      ];
      var model = new tracing.TimelineModel();
      model.importEvents(events);

      var t53track = new tracing.TimelineThreadTrack();
      t53track.thread = model.processes[52].threads[53];

      var selection = new tracing.TimelineSelection();
      t53track.addAllObjectsMatchingFilterToSelection(
        new tracing.TimelineFilter('c'), selection);
      assertEquals(2, selection.length);

      return selection;
    }

    function createSelectionWithCounters(numSamples) {
      if (numSamples > 2 || numSamples < 1) 
        throw new Error('This function only supports 1 or 2 samples');
      var events = [
        {name: 'ctr', args: {'value': 0}, pid: 1, ts: 0, cat: 'foo', tid: 1,
         ph: 'C', id: 0},
        {name: 'ctr', args: {'value': 10}, pid: 1, ts: 10, cat: 'foo', tid: 1,
         ph: 'C', id: 0}
      ];
      var model = new tracing.TimelineModel(events);
      var p = model.processes[1];
      var ctr = model.processes[1].counters['foo.ctr[0]'];
      assertEquals('ctr[0]', ctr.name);
      assertEquals(2, ctr.numSamples);
      assertEquals(1, ctr.numSeries);
      assertArrayEquals([0, 0.01], ctr.timestamps);
      assertArrayEquals([0, 10], ctr.samples);

      var selection = new tracing.TimelineSelection();
      var t1track = new tracing.TimelineThreadTrack();
      selection.addCounterSample(t1track, ctr, 1);

      if (numSamples == 1)
        return selection;

      selection.addCounterSample(t1track, ctr, 0);
      return selection;
    }

    function appendTestResult(title, el) {
      var titleEl = document.createElement('div');
      titleEl.textContent = title;
      titleEl.style.fontSize = '120%';
      titleEl.style.marginBottom = '0px';

      var groupEl = document.createElement('div');
      groupEl.style.marginBottom = '48px';
      groupEl.style.border = '1px solid black';

      groupEl.appendChild(el);
      document.body.appendChild(titleEl);
      document.body.appendChild(groupEl);
    }

    tests.testAnalysisViewWithSingleSlice = function() {
      var selection = createSelectionWithSingleSlice();

      var analysisEl = new tracing.TimelineAnalysisView();
      analysisEl.selection = selection;

      appendTestResult("Single thread slice", analysisEl);
    }

    tests.testAnalysisViewWithMultipleSlices = function() {
      var selection = createSelectionWithTwoSlices();

      var analysisEl = new tracing.TimelineAnalysisView();
      analysisEl.selection = selection;

      appendTestResult("Multiple non nested thread slices", analysisEl);
    }

    function StubAnalysisResults() {
      this.tables = [];
    }
    StubAnalysisResults.prototype = {
      __proto__: Object.protoype,

      appendTable: function(parent, className) {
        var table = {
          className: className,
          rows: [],
        };
        table.className = className;
        this.tables.push(table);
        return table;
      },

      appendTableHeader: function(table, label) {
        if (table.tableHeader)
          throw new Error("Only one summary header allowed.");
        table.tableHeader = label;
      },

      appendSummaryRow: function(table, label, opt_text) {
        table.rows.push({label: label,
                         text: opt_text});
      },

      appendSpacingRow: function(table) {
        table.rows.push({spacing: true});
      },

      appendSummaryRowTime: function(table, label, time) {
        table.rows.push({label: label,
                         time: time});
      },

      appendSliceRow: function(table, label, duration, occurences, details) {
        table.rows.push({label: label,
                         duration: duration,
                         occurences: occurences,
                         details: details});
      }
    };

    tests.testAnalyzeSelectionWithSingleSlice = function() {
      var selection = createSelectionWithSingleSlice();

      var results = new StubAnalysisResults();
      tracing.analyzeSelection_(results, selection);
      assertEquals(1, results.tables.length);
      var table = results.tables[0];
      assertEquals('Selected item:', table.tableHeader);
      assertEquals(3, table.rows.length)

      assertEquals("b", table.rows[0].text);
      assertEquals(0, table.rows[1].time);
      assertAlmostEquals(0.002, table.rows[2].time);
    }


    tests.testAnalyzeSelectionWithTwoSlices = function() {
      var selection = createSelectionWithTwoSlices();

      var results = new StubAnalysisResults();
      tracing.analyzeSelection_(results, selection);
      assertEquals(1, results.tables.length);
      var table = results.tables[0];
      assertEquals('Slices:', table.tableHeader);
      assertEquals(6, table.rows.length)

      assertEquals("a", table.rows[0].label);
      assertEquals(1, table.rows[0].occurences);
      assertAlmostEquals(0.04, table.rows[0].duration);

      assertEquals("aa", table.rows[1].label);
      assertEquals(1, table.rows[1].occurences);
      assertAlmostEquals(0.06, table.rows[1].duration);

      assertEquals("*Totals", table.rows[2].label);
      assertEquals(2, table.rows[2].occurences);
      assertAlmostEquals(0.1, table.rows[2].duration);

      assertEquals("Selection start", table.rows[4].label);
      assertAlmostEquals(0, table.rows[4].time);

      assertEquals("Selection extent", table.rows[5].label);
      assertAlmostEquals(0.18, table.rows[5].time);
    }

    tests.testAnalyzeSelectionWithTwoSlicesSameTitle = function() {
      var selection = createSelectionWithTwoSlicesSameTitle();

      var results = new StubAnalysisResults();
      tracing.analyzeSelection_(results, selection);
      assertEquals(1, results.tables.length);
      var table = results.tables[0];
      assertEquals('Slices:', table.tableHeader);
      assertEquals(5, table.rows.length)

      assertEquals("c", table.rows[0].label);
      assertEquals(2, table.rows[0].occurences);
      assertAlmostEquals(0.1, table.rows[0].duration);
      assertAlmostEquals(0.04, table.rows[0].details.min);
      assertAlmostEquals(0.06, table.rows[0].details.max);
      assertAlmostEquals(0.05, table.rows[0].details.avg);

      assertEquals("*Totals", table.rows[1].label);
      assertEquals(2, table.rows[1].occurences);
      assertAlmostEquals(0.1, table.rows[1].duration);

      assertEquals("Selection start", table.rows[3].label);
      assertAlmostEquals(0, table.rows[3].time);

      assertEquals("Selection extent", table.rows[4].label);
      assertAlmostEquals(0.18, table.rows[4].time);
    }

    function testAnalyzeSelectionWithSingleCounter() {
      var selection = createSelectionWithCounters(1);

      var results = new StubAnalysisResults();
      tracing.analyzeSelection_(results, selection);
      assertEquals(1, results.tables.length);
      var table = results.tables[0];
      assertEquals('Selected counter:', table.tableHeader);
      assertEquals(3, table.rows.length)

      assertEquals("Title", table.rows[0].label);
      assertEquals("Timestamp", table.rows[1].label);
      assertEquals("Value", table.rows[2].label);
      assertEquals(10, table.rows[2].text);
    }

    // TODO(brendalee): Test the case of a selection with multiple counters.
    tests.testAnalyzeSelectionWithTwoCounters = function() {
    }

    // TODO(tbd): Test the case of a selection with both counters and slices.
    tests.testAnalyzeSelectionWithCounterAndSlices = function() {
    }

    return tests;
});
  </script>
</body>
</html>
