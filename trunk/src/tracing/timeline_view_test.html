<!DOCTYPE HTML>
<html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<head>
<title>TimelineView tests</title>
<script src="/src/base.js"></script>
<link rel="shortcut icon" href="data:image/x-icon;base64," type="image/x-icon">
</head>
<body>
  <script>
    base.require('base.unittest');
    base.require('tracing.test_utils');
    base.require('tracing.timeline_view');
    base.require('tracing.trace_model');
  </script>
  <script>
    'use strict';

    var newSliceNamed = tracing.test_utils.newSliceNamed;

    function createFullyPopulatedModel(opt_withError, opt_withMetadata) {
      var withError = opt_withError !== undefined ? opt_withError : true;
      var withMetadata = opt_withMetadata !== undefined ?
          opt_withMetadata : true;

      var num_tests = 50;
      var testIndex = 0;
      var startTime = 0;

      var model = new tracing.TraceModel();
      for (testIndex = 0; testIndex < num_tests; ++testIndex) {
        var process = model.getOrCreateProcess(10000 + testIndex);
        if (testIndex % 2 == 0) {
          var thread = process.getOrCreateThread('Thread Name Here');
          thread.slices.push(new tracing.trace_model.Slice(
              'foo', 'a', 0, startTime, {}, 1));
          thread.slices.push(new tracing.trace_model.Slice(
              'bar', 'b', 0, startTime + 23, {}, 10));
        } else {
          var thread = process.getOrCreateThread('Name');
          thread.slices.push(new tracing.trace_model.Slice(
              'foo', 'a', 0, startTime + 4, {}, 11));
          thread.slices.push(new tracing.trace_model.Slice(
              'bar', 'b', 0, startTime + 22, {}, 14));
        }
      }
      var p1000 = model.getOrCreateProcess(1000);
      var objects = p1000.objects;
      objects.idWasCreated('0x1000', 'cc', 'LayerTreeHostImpl', 10);
      objects.addSnapshot('0x1000', 'cc', 'LayerTreeHostImpl', 10,
                          'snapshot-1');
      objects.addSnapshot('0x1000', 'cc', 'LayerTreeHostImpl', 25,
                          'snapshot-2');
      objects.addSnapshot('0x1000', 'cc', 'LayerTreeHostImpl', 40,
                          'snapshot-3');
      objects.idWasDeleted('0x1000', 'cc', 'LayerTreeHostImpl', 45);
      model.updateCategories_();

      // Add a known problematic piece of data to test the import errors UI.
      model.importErrors.push('Synthetic Import Error');
      model.updateBounds();

      // Add data with metadata information stored
      model.metadata.push({name: 'a', value: 'testA'});
      model.metadata.push({name: 'b', value: 'testB'});
      model.metadata.push({name: 'c', value: 'testC'});

      return model;
    }

    /*
     * This test just instantiates a View and adds it to the DOM
     * to help with non-unittest UI work.
     */
    function instantiateViewHelper() {
      var timelineView = document.querySelector('.timeline-view');
      if (!timelineView) {
        timelineView = instantiateView.call(this);
      }
      return timelineView;
    }

    function instantiateView() {
      var model = createFullyPopulatedModel(true, true);

      var view = new tracing.TimelineView();
      view.style.height = '400px';
      view.model = model;
      view.tabIndex = 0;
      view.focusElement = view;

      var selection = new tracing.Selection();
      view.timeline.addAllObjectsMatchingFilterToSelection({
          matchSlice: function() { return true;}
      }, selection);
      view.timeline.selection = selection;

      this.addHTMLOutput(undefined, view);
      return view;
    }

    function testChangeModelToSomethingDifferent() {
      var model00 = createFullyPopulatedModel(false, false);
      var model11 = createFullyPopulatedModel(true, true);

      var view = new tracing.TimelineView();
      view.style.height = '400px';
      view.model = model00;
      view.model = undefined;
      view.model = model11;
      view.model = model00;
    }


    function testSetModelToSameThingAgain() {
      var model = createFullyPopulatedModel(false, false);

      // Create a view with am model.
      var view = new tracing.TimelineView();
      view.style.height = '400px';
      view.model = model;

      // Mutate the model and update the view.
      var t123 = model.getOrCreateProcess(123).getOrCreateThread(123);
      t123.pushSlice(newSliceNamed('somethingUnusual', 0, 5));
      view.model = model;

      // Verify that the new bits of the model show up in the view.
      var selection = new tracing.Selection();
      var filter = new tracing.TitleFilter('somethingUnusual');
      view.timeline.addAllObjectsMatchingFilterToSelection(filter, selection);
      assertEquals(selection.length, 1);
    }

    function testChangeModelToSomethingDifferent() {
      var model00 = createFullyPopulatedModel(false, false);
      var model11 = createFullyPopulatedModel(true, true);

      var view = new tracing.TimelineView();
      view.style.height = '400px';
      view.model = model00;
      view.model = undefined;
      view.model = model11;
      view.model = model00;
    }


    function testSetModelToSameThingAgain() {
      var model = createFullyPopulatedModel(false, false);

      // Create a view with am model.
      var view = new tracing.TimelineView();
      view.style.height = '400px';
      view.model = model;

      // Mutate the model and update the view.
      var t123 = model.getOrCreateProcess(123).getOrCreateThread(123);
      t123.pushSlice(newSliceNamed('somethingUnusual', 0, 5));
      view.model = model;

      // Verify that the new bits of the model show up in the view.
      var selection = new tracing.Selection();
      var filter = new tracing.TitleFilter('somethingUnusual');
      view.timeline.addAllObjectsMatchingFilterToSelection(filter, selection);
      assertEquals(selection.length, 1);
    }

    function testSetModelUpdatesCategories() {
      var model = new tracing.TraceModel();
      var p1 = model.getOrCreateProcess(1);
      var t1 = p1.getOrCreateThread(1);

      t1.pushSlice(new tracing.trace_model.ThreadSlice(
          'foo', 'a', 0, 1, {}, 3));
      t1.pushSlice(new tracing.trace_model.ThreadSlice(
          'bar', 'b', 0, 1.1, {}, 2.8));
      t1.pushSlice(new tracing.trace_model.ThreadSlice(
          'baz', 'b', 0, 1.2, {}, 2.4));
      model.updateCategories_();
      model.updateBounds();

      var view = new tracing.TimelineView();
      view.settings.set('foo', true, 'categories');
      view.settings.set('bar', false, 'categories');
      view.model = model;

      assertUndefined(view.timeline.categoryFilter_.categories_['foo']);
      assertTrue(view.timeline.categoryFilter_.categories_['bar']);
      assertUndefined(view.timeline.categoryFilter_.categories_['baz']);
    }

    function testUpdateCategoryFilterFromSettings() {
      var view = new tracing.TimelineView();
      view.timeline_ = {};
      view.settings.set('foo', true, 'categories');
      view.settings.set('bar', false, 'categories');
      view.settings.set('baz', false, 'categories');
      view.updateCategoryFilterFromSettings_();
      assertUndefined(view.timeline_.categoryFilter.categories_['foo']);
      assertTrue(view.timeline_.categoryFilter.categories_['bar']);
      assertTrue(view.timeline_.categoryFilter.categories_['baz']);
    }

    function visibleTracks(trackButtons) {
      return trackButtons.reduce(function(numVisible, button) {
        var style = button.parentElement.style;
        var visible = (style.display.indexOf('none') === -1);
        return visible ? numVisible + 1 : numVisible;
      }, 0);
    }

    function toggleRegExpSelectors(regexpSelectors) {
      for (var i = 0; i < regexpSelectors.length; i++) {
        var selector = regexpSelectors[i];
        if (selector.regexp.source !== ui.RegExpSelector.defaultSource)
          selector.isOn = !selector.isOn;
      }
    }

    function modelsEquivalent(lhs, rhs) {
      if (lhs.length !== rhs.length)
        return false;
      return lhs.every(function(lhsItem, index) {
        var rhsItem = rhs[index];
        return rhsItem.regexpText === lhsItem.regexpText &&
            rhsItem.isOn === lhsItem.isOn;
      });
    }

    function testTrackSelector() {
      var timeline = instantiateViewHelper.call(this);

      var trackSelectorButton =
          timeline.querySelector('.track-selector-button');
      trackSelectorButton.click();

      var showHiddenTracks =
          timeline.querySelector('.show-hidden-tracks-button');
      // To start no tracks are disabled, so we can't Show Hidden Tracks
      assertTrue(showHiddenTracks.getAttribute('disabled') === '');

      var trackButtonsDOM = timeline.querySelectorAll('.track-button');
      var trackButtons = [];
      for (var i = 0; i < trackButtonsDOM.length; i++)
        trackButtons.push(trackButtonsDOM[i]);

      var lastTrackButton = trackButtons[trackButtons.length - 1];
      lastTrackButton.scrollIntoViewIfNeeded();
      lastTrackButton.click();

      // The track is hidden
      var styleDisplay = lastTrackButton.parentElement.style.display;
      assertTrue(styleDisplay.indexOf('none') !== -1);
      // A hidden track can now be re-shown.
      assertTrue(showHiddenTracks.getAttribute('disabled') === null);

      showHiddenTracks.click();
       // The track is no longer hidden
      styleDisplay = lastTrackButton.parentElement.style.display;
      assertTrue(styleDisplay.indexOf('none') === -1);
      // No hidden tracks to Show
      assertTrue(showHiddenTracks.getAttribute('disabled') === '');

      var trackSelector = timeline.querySelector('.track-selector');
      // initially we have 50 tracks
      assertTrue(visibleTracks(trackButtons) === 50);

      trackSelector.trackSelectorModel = [
        {regexp: 'Thread', isOn: true},
        {regexp: 'Name:', isOn: false}
      ];
      // 25 Tracks have "Thread'
      assertTrue(visibleTracks(trackButtons) === 25);

      var regexpSelectors =
          trackSelector.querySelectorAll('.regexp-selector');
      toggleRegExpSelectors(regexpSelectors);
      // 25 Tracks have 'Name:'
      assertTrue(visibleTracks(trackButtons) === 25);

      toggleRegExpSelectors(regexpSelectors);
      // 25 Tracks have "Thread'
      assertTrue(visibleTracks(trackButtons) === 25);

      showHiddenTracks.click();
      assertEquals(visibleTracks(trackButtons), 50);

      var blanks = 0;
      for (var i = 0; i < regexpSelectors.length; i++) {
        var blankRegExp = ui.RegExpSelector.defaultSource;
        if (regexpSelectors[i].regexp.source === blankRegExp) {
          blanks++;
        }
      }
      assertEquals(blanks, 1);
      trackSelectorButton.click();

      var settings = new base.Settings();
      var trackSelectorModelJSON = settings.get('TrackSelector');
      var actual = JSON.parse(trackSelectorModelJSON);
      var expected = [
        {'regexpText': 'Thread', 'isOn': false},
        {'regexpText': 'Name:', 'isOn': false},
        {'regexpText': '(?:)', 'isOn': false}
      ];
      // We've stored what we set in the test above.
      assertTrue(modelsEquivalent(actual, expected));

      expected.shift();

      settings.set('TrackSelector', JSON.stringify(expected));
      var aTrackSelector = new tracing.tracks.TrackSelector();
      actual = aTrackSelector.trackSelectorModel;
      // we recovered what we stored
      assertTrue(modelsEquivalent(actual, expected));

      settings.set('TrackSelector', 'junk');
      aTrackSelector = new tracing.tracks.TrackSelector();
      actual = aTrackSelector.trackSelectorModel;
      // we fallback to default
      expected = tracing.tracks.TrackSelector.defaultModel;
      assertTrue(modelsEquivalent(actual, expected));
    }

</script>
</body>
</html>
