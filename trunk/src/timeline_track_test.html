<!DOCTYPE HTML>
<html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<head i18n-values="dir:textdirection;">
<title>TimelineTrack tests</title>
<style>
.timeline-container {
  border: 1px solid red;
}
</style>
<script src="base.js"></script>
</head>
<body>
<script>
  'use strict';
  base.defineModule('timeline_track_test')
      .dependsOn('unittest',
                 'test_utils',
                 'timeline' /* TODO(nduca): reduce dependency to tracks */)
      .runAllTests(function() {

  var tests = {};

  var TimelineAsyncSlice = tracing.TimelineAsyncSlice;
  var TimelineAsyncSliceGroup = tracing.TimelineAsyncSliceGroup;
  var TimelineAsyncSliceGroupTrack = tracing.TimelineAsyncSliceGroupTrack;
  var TimelineCounter = tracing.TimelineCounter;
  var TimelineCounterTrack = tracing.TimelineCounterTrack;
  var TimelineCpu = tracing.TimelineCpu;
  var TimelineCpuTrack = tracing.TimelineCpuTrack;
  var TimelineProcess = tracing.TimelineProcess;
  var TimelineSelection = tracing.TimelineSelection;
  var TimelineSliceGroup = tracing.TimelineSliceGroup;
  var TimelineSliceGroupTrack = tracing.TimelineSliceGroupTrack;
  var TimelineSliceTrack = tracing.TimelineSliceTrack;
  var TimelineSlice = tracing.TimelineSlice;
  var TimelineThread = tracing.TimelineThread;
  var TimelineThreadSlice = tracing.TimelineThreadSlice;
  var TimelineThreadTrack = tracing.TimelineThreadTrack;
  var TimelineViewport = tracing.TimelineViewport;
  var newAsyncSlice = test_utils.newAsyncSlice;
  var newAsyncSliceNamed = test_utils.newAsyncSliceNamed;
  var newSliceNamed = test_utils.newSliceNamed;
  var testDivs = {};

  tests.testBasicSlices = function() {
    var testEl = this.addHTMLOutput();
    var track = TimelineSliceTrack();
    testEl.appendChild(track);
    track.heading = 'testBasicSlices';
    track.slices = [
      new TimelineSlice('', 'a', 0, 1, {}, 1),
      new TimelineSlice('', 'b', 1, 2.1, {}, 4.8),
      new TimelineSlice('', 'b', 1, 7, {}, 0.5),
      new TimelineSlice('', 'c', 2, 7.6, {}, 0.4)
    ];
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 8.8, track.clientWidth);
  }

  tests.testFindAllObjectsMatchingInSliceTrack = function() {
    var track = TimelineSliceTrack();
    track.slices = [
      new TimelineSlice('', 'a', 0, 1, {}, 1),
      new TimelineSlice('', 'b', 1, 2.1, {}, 4.8),
      new TimelineSlice('', 'b', 1, 7, {}, 0.5),
      new TimelineSlice('', 'c', 2, 7.6, {}, 0.4)
    ];
    var selection = new TimelineSelection();
    track.addAllObjectsMatchingFilterToSelection(
        new tracing.TimelineTitleFilter("b"), selection);

    assertEquals(2, selection.length);
    assertEquals(track.slices[1], selection[0].slice);
    assertEquals(track.slices[2], selection[1].slice);
  }

  tests.testShrinkingSliceSizes = function() {
    var testEl = this.addHTMLOutput();
    var track = TimelineSliceTrack();
    testEl.appendChild(track);
    track.heading = 'testShrinkingSliceSizes';
    var x = 0;
    var widths = [10, 5, 4, 3, 2, 1, 0.5, 0.4, 0.3, 0.2, 0.1, 0.05];
    var slices = [];
    for (var i = 0; i < widths.length; i++) {
      var s = new TimelineSlice('', 'a', 1, x, {}, widths[i]);
      x += s.duration + 0.5;
      slices.push(s);
    }
    track.slices = slices;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 1.1 * x, track.clientWidth);
  }

  tests.testSelectionHitTesting = function() {
    var testEl = this.addHTMLOutput();
    var track = new TimelineSliceTrack();
    testEl.appendChild(track);
    track.heading = 'testSelectionHitTesting';
    track.headingWidth = '100px';
    track.slices = [
      new TimelineSlice('', 'a', 0, 1, {}, 1),
      new TimelineSlice('', 'b', 1, 2.1, {}, 4.8)
    ];
    track.style.width = '500px';
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 7.6, track.clientWidth);
    var clientRect = track.getBoundingClientRect();

    var selection = new TimelineSelection();
    track.addIntersectingItemsToSelection(1.5, clientRect.top + 5, selection);
    assertEquals(track.slices[0], selection[0].slice);

    var selection = new TimelineSelection();
    track.addIntersectingItemsToSelection(2, clientRect.top + 5, selection);
    assertEquals(0, selection.length);

    var selection = new TimelineSelection();
    track.addIntersectingItemsToSelection(6.8, clientRect.top + 5, selection);
    assertEquals(track.slices[1], selection[0].slice);

    var selection = new TimelineSelection();
    track.addIntersectingItemsToSelection(6.9, clientRect.top + 5, selection);
    assertEquals(0, selection.length);
  }

  tests.testSelectionHitTestingWithTimelineThreadTrack = function() {
    var model = new tracing.TimelineModel();
    var p1 = model.getOrCreateProcess(1);
    var t1 = p1.getOrCreateThread(1);
    t1.pushSlice(new tracing.TimelineThreadSlice('', 'a', 0, 1, {}, 4));
    t1.pushSlice(new tracing.TimelineThreadSlice('', 'b', 0, 5.1, {}, 4));

    var testEl = this.addHTMLOutput();
    var track = new tracing.TimelineThreadTrack();
    testEl.appendChild(track);
    track.heading = 'testSelectionHitTestingWithTimelineThreadTrack';
    track.headingWidth = '100px';
    track.thread = t1;

    track.style.width = '500px';
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 10, track.clientWidth);
    var clientRect = track.getBoundingClientRect();

    var selection = new TimelineSelection();
    track.addIntersectingItemsToSelection(1.5, clientRect.top + 5, selection);
    assertEquals(t1.slices[0], selection[0].slice);

    var selection = new TimelineSelection();
    track.addIntersectingItemsInRangeToSelection(1.5, 1.8, clientRect.top + 5, clientRect.top + 7, selection);
    assertEquals(t1.slices[0], selection[0].slice);
  }

  tests.testBasicCpu = function() {
    var testEl = this.addHTMLOutput();

    var cpu = new TimelineCpu(7);
    cpu.slices = [
      new TimelineSlice('', 'a', 0, 1, {}, 1),
      new TimelineSlice('', 'b', 1, 2.1, {}, 4.8)
    ];
    cpu.updateBounds();

    var track = TimelineCpuTrack();
    testEl.appendChild(track);
    track.heading = 'CPU ' + cpu.cpuNumber;
    track.cpu = cpu;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 11.1, track.clientWidth);
  }

  tests.testViewport = function() {
    var testEl = this.addHTMLOutput();

    var track = tracing.TimelineViewportTrack();
    testEl.appendChild(track);
    track.viewport = new TimelineViewport(testEl);
    track.viewport.setPanAndScale(0,
        track.clientWidth / 1000);
  }

  tests.testBasicCounter = function() {
    var testEl = this.addHTMLOutput();

    var ctr = new TimelineCounter(undefined,
                                  'testBasicCounter', '', 'testBasicCounter');
    ctr.seriesNames = ['value1', 'value2'];
    ctr.seriesColors = [tracing.getStringColorId('testBasicCounter.value1'),
                        tracing.getStringColorId('testBasicCounter.value2')];
    ctr.timestamps = [0, 1, 2, 3, 4, 5, 6, 7];
    ctr.samples = [0, 5,
                   3, 3,
                   1, 1,
                   2, 1.1,
                   3, 0,
                   1, 7,
                   3, 0,
                   3.1, 0.5];
    ctr.updateBounds();

    var track = new TimelineCounterTrack();
    testEl.appendChild(track);
    track.heading = ctr.name;
    track.counter = ctr;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 7.7, track.clientWidth);
  }

  function runOffscreenCounterTest(timestamps, samples, testFn) {
    var testEl = document.createElement('div');
    var ctr = new TimelineCounter(undefined,
                                  'foo', '', 'foo');
    var n = samples.length / timestamps.length;
    ctr.timestamps = timestamps;
    ctr.samples = samples;
    ctr.seriesNames = []
    ctr.seriesColors = []
    for (var i = 0; i < n; ++i) {
      ctr.seriesNames.push('value' + i);
      ctr.seriesColors.push(tracing.getStringColorId(ctr.seriesNames[i]));
    }
    ctr.updateBounds();

    var track = new TimelineCounterTrack();
    testEl.appendChild(track);
    document.body.appendChild(testEl);

    track.heading = ctr.name;
    track.counter = ctr;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 10, track.clientWidth);

    try {
      testFn(ctr, track);
    } finally {
      document.body.removeChild(testEl);
    }
  }

  tests.testBasicCounterXPointPicking = function() {
    var timestamps = [0, 1, 2, 3, 4, 5, 6, 7];
    var samples = [0, 5,
                   3, 3,
                   1, 1,
                   2, 1.1,
                   3, 0,
                   1, 7,
                   3, 0,
                   3.1, 0.5];
    runOffscreenCounterTest(timestamps, samples, function(ctr, track) {
      var clientRect = track.getBoundingClientRect();
      var y75 = clientRect.top + 0.75 * clientRect.height;
      var sel;

      // In bounds.
      sel = new tracing.TimelineSelection();
      track.addIntersectingItemsToSelection(1.5, y75, sel);
      assertEquals(1, sel.length);
      assertEquals(track, sel[0].track);
      assertEquals(ctr, sel[0].counter);
      assertEquals(1, sel[0].sampleIndex);

      // Outside bouds.
      sel = new tracing.TimelineSelection();
      track.addIntersectingItemsToSelection(-1, y75, sel);
      assertEquals(0, sel.length);

      sel = new tracing.TimelineSelection();
      track.addIntersectingItemsToSelection(8, y75, sel);
      assertEquals(0, sel.length);
    });
  }

  /* You'll need visual inspection to test eliding with this one. */
  tests.testElideVisualInspection = function() {
    var optDicts = [{ trackName: 'elideOff', elide: false },
                    { trackName: 'elideOn', elide: true }];
    for (var dictIndex in optDicts) {
      var dict = optDicts[dictIndex];
      var testEl = this.addHTMLOutput(dict.trackName);
      var track = new TimelineSliceTrack();
      if (dict.elide) {
        track.SHOULD_ELIDE_TEXT = true;
      } else {
        track.SHOULD_ELIDE_TEXT = false;
      }
      var tooLongTitle = 'Unless eliding this SHOULD NOT BE DISPLAYED.  ';
      var bigTitle = 'Very big title name that goes on longer ' +
                     'than you may expect';
      testEl.appendChild(track);
      track.heading = 'Visual: ' + dict.trackName;
      track.slices = [
          // title, colorId, start, args, opt_duration
          new TimelineSlice('', 'a ' + tooLongTitle + bigTitle, 0, 1, {}, 1),
          new TimelineSlice('', bigTitle, 1, 2.1, {}, 4.8),
          new TimelineSlice('', 'cccc cccc cccc', 1, 7, {}, 0.5),
          new TimelineSlice('', 'd', 2, 7.6, {}, 1.0)
      ];
      track.viewport = new TimelineViewport(testEl);
      track.viewport.xSetWorldRange(0, 9.5, track.clientWidth);
    }
  }

  tests.testElide = function() {
    var testEl = this.addHTMLOutput();
    var track = new TimelineSliceTrack();
    testEl.appendChild(track);
    var bigtitle = 'Super duper long long title ' +
      'holy moly when did you get so verbose?';
    var smalltitle = 'small';
    track.viewport = new TimelineViewport(testEl);
    track.heading = 'testElide';
    track.slices = [
        // title, colorId, start, args, opt_duration
        new TimelineSlice('', bigtitle, 0, 1, {}, 1),
        new TimelineSlice('', smalltitle, 1, 2, {}, 1)
    ];
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 3.3, track.clientWidth);
    var stringWidthPair = undefined;
    var pixWidth = track.viewport_.xViewVectorToWorld(1);

    // Small titles on big slices are not elided.
    stringWidthPair = track.elidedTitleCache.get(track, pixWidth, smalltitle,
      track.labelWidth(smalltitle), 1);
    assertEquals(smalltitle, stringWidthPair.string);
    // Keep shrinking the slice until eliding starts.
    var elidedWhenSmallEnough = false;
    for (var sliceLength = 1; sliceLength >= 0.00001; sliceLength /= 2.0) {
      stringWidthPair = track.elidedTitleCache.get(track, pixWidth, smalltitle,
        track.labelWidth(smalltitle), sliceLength);
      if (stringWidthPair.string.length < smalltitle.length) {
        elidedWhenSmallEnough = true;
        break;
      }
    }
    assertTrue(elidedWhenSmallEnough);

    // Big titles are elided immediately.
    var superBigTitle = '';
    for (var x = 0; x < 10; x++) {
      superBigTitle += bigtitle;
    }
    stringWidthPair = track.elidedTitleCache.get(track, pixWidth,
      superBigTitle, track.labelWidth(superBigTitle), 1);
    assertTrue(stringWidthPair.string.length < superBigTitle.length);
    // And elided text ends with ...
    var len = stringWidthPair.string.length;
    assertEquals('...', stringWidthPair.string.substring(len - 3, len));
  }

  tests.testTimelineThreadTrackWithRegularSlices = function() {
    var testEl = this.addHTMLOutput();
    var track = TimelineThreadTrack();
    testEl.appendChild(track);
    track.heading = 'testTimelineThreadTrackWithRegularSlices';
    var thread = new TimelineThread(new TimelineProcess(7), 1);
    thread.pushSlices([
        new TimelineThreadSlice('', 'a', 0, 1, {}, 1),
        new TimelineThreadSlice('', 'b', 1, 2.1, {}, 4.8),
        new TimelineThreadSlice('', 'b', 1, 7, {}, 0.5),
        new TimelineThreadSlice('', 'c', 2, 7.6, {}, 0.4),
        new TimelineThreadSlice('', 'd', 3, 1.1, {}, 0.8),
        new TimelineThreadSlice('', 'e', 4, 7.1, {}, 0.3)
    ]);
    thread.updateBounds();
    track.heading = 'thread regular';
    track.headingWidth = '150px';
    track.toolTip = thread.userFriendlyDetails + ':';
    track.thread = thread;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 8.2, track.clientWidth);
  }

  tests.testTimelineThreadTrackWithTallSlices = function() {
    var testEl = this.addHTMLOutput();
    var track = TimelineThreadTrack();
    testEl.appendChild(track);
    track.heading = 'testTimelineThreadTrackWithTallSlices';
    var thread = new TimelineThread(new TimelineProcess(7), 1);
    thread.pushSlices([
      new TimelineThreadSlice('', 'a', 1, 0, {}, 1),
      new TimelineThreadSlice('', 'b', 2, 0.1, {}, 0.8),
      new TimelineThreadSlice('', 'c', 3, 0.15, {}, 0.70),
      new TimelineThreadSlice('', 'd', 4, 0.20, {}, 0.50),
      new TimelineThreadSlice('', 'e', 5, 0.30, {}, 0.28),
      new TimelineThreadSlice('', 'e', 6, 0.35, {}, 0.20),
      new TimelineThreadSlice('', 'f', 7, 0.40, {}, 0.10)
    ]);
    thread.updateBounds();
    track.heading = 'thread tall';
    track.headingWidth = '150px';
    track.toolTip = thread.userFriendlyDetails + ':';
    track.thread = thread;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 1.1, track.clientWidth);
  }

  tests.testTimelineThreadTrackWithRegularAndAsyncSlices = function() {
    var testEl = this.addHTMLOutput();
    var track = TimelineThreadTrack();
    testEl.appendChild(track);
    var thread = new TimelineThread(new TimelineProcess(7), 1);
    thread.pushSlices([
        new TimelineThreadSlice('', 'a', 0, 1, {}, 1),
        new TimelineThreadSlice('', 'b', 1, 2.1, {}, 4.8),
        new TimelineThreadSlice('', 'b', 1, 7, {}, 0.5),
        new TimelineThreadSlice('', 'c', 2, 7.6, {}, 0.4),
        new TimelineThreadSlice('', 'd', 3, 1.1, {}, 0.8),
        new TimelineThreadSlice('', 'e', 4, 7.1, {}, 0.3)
    ]);
    thread.asyncSlices.push(newAsyncSlice(1.2, 7.2 - 1.2, thread, thread));
    thread.asyncSlices.push(newAsyncSlice(1.3, 7.3 - 1.3, thread, thread));
    thread.updateBounds();
    track.heading = 'thread regular + async';
    track.headingWidth = '150px';
    track.toolTip = thread.userFriendlyDetails + ':';
    track.thread = thread;
    track.viewport = new TimelineViewport(testEl);
    track.viewport.xSetWorldRange(0, 8.15, track.clientWidth);
  }

  tests.testTimelineSliceTrackAddItemNearToProvidedHit = function() {
    var track = new TimelineSliceTrack();
    track.slices = [
      new TimelineSlice('', 'a', 0, 1, {}, 1),
      new TimelineSlice('', 'b', 1, 2.1, {}, 4.8),
      new TimelineSlice('', 'b', 1, 7, {}, 0.5),
      new TimelineSlice('', 'c', 2, 7.6, {}, 0.4)
    ];
    var sel = new tracing.TimelineSelection();
    track.addAllObjectsMatchingFilterToSelection(new tracing.TimelineTitleFilter("b"), sel);
    var ret;

    // Select to the right of B.
    var selRight = new tracing.TimelineSelection();
    ret = track.addItemNearToProvidedHitToSelection(sel[0], 1, selRight);
    assertTrue(ret);
    assertEquals(track.slices[2], selRight[0].slice);

    // Select to the right of the 2nd b.
    var selRight2 = new tracing.TimelineSelection();
    ret = track.addItemNearToProvidedHitToSelection(sel[0], 2, selRight2);
    assertTrue(ret);
    assertEquals(track.slices[3], selRight2[0].slice);

    // Select to 2 to the right of the 2nd b.
    var selRightOfRight = new tracing.TimelineSelection();
    ret = track.addItemNearToProvidedHitToSelection(selRight[0], 1, selRightOfRight);
    assertTrue(ret);
    assertEquals(track.slices[3], selRightOfRight[0].slice);

    // Select to the right of the rightmost slice.
    var selNone = new tracing.TimelineSelection();
    ret = track.addItemNearToProvidedHitToSelection(selRightOfRight[0], 1, selNone);
    assertFalse(ret);
    assertEquals(0, selNone.length);

    // Select A and then select left.
    var sel = new tracing.TimelineSelection();
    track.addAllObjectsMatchingFilterToSelection(new tracing.TimelineTitleFilter("a"), sel);
    var ret;

    selNone = new tracing.TimelineSelection();
    ret = track.addItemNearToProvidedHitToSelection(sel[0], -1, selNone);
    assertFalse(ret);
    assertEquals(0, selNone.length);
  }

  tests.testFilterThreadSlices = function() {
    var thread = new TimelineThread(new TimelineProcess(7), 1);
    thread.pushSlice(newSliceNamed('a', 0, 0));
    thread.asyncSlices.push(newAsyncSliceNamed('a', 0, 5, t, t));

    var t = new TimelineThreadTrack();
    t.thread = thread;

    assertTrue(t.tracks_[1].visible);
    assertEquals(1, t.tracks_[1].tracks_.length);
    assertTrue(t.tracks_[1].visible);
    assertEquals(1, t.tracks_[2].tracks_.length);

    t.categoryFilter = new tracing.TimelineTitleFilter('x');
    assertFalse(t.tracks_[1].visible);
    assertFalse(t.tracks_[1].visible);

    t.categoryFilter = new tracing.TimelineTitleFilter('a');
    assertTrue(t.tracks_[1].visible);
    assertEquals(1, t.tracks_[1].tracks_.length);
    assertTrue(t.tracks_[1].visible);
    assertEquals(1, t.tracks_[2].tracks_.length);
  }

  tests.testSubRowBuilderBasic = function() {
    var group = new TimelineSliceGroup();
    var sA = group.pushSlice(newSliceNamed("a", 1, 2));
    var sB = group.pushSlice(newSliceNamed("a", 3, 1));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(1, subRows.length);
    assertEquals(2, subRows[0].length);
    assertArrayEquals([sA, sB], subRows[0]);
  }

  tests.testSubRowBuilderBasic2 = function() {
    var group = new TimelineSliceGroup();
    var sA = group.pushSlice(newSliceNamed("a", 1, 4));
    var sB = group.pushSlice(newSliceNamed("b", 3, 1));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(2, subRows.length);
    assertEquals(1, subRows[0].length);
    assertEquals(1, subRows[1].length);
    assertArrayEquals([sA], subRows[0]);
    assertArrayEquals([sB], subRows[1]);
  }

  tests.testSubRowBuilderNestedExactly = function() {
    var group = new TimelineSliceGroup();
    var sA = group.pushSlice(newSliceNamed("a", 1, 4));
    var sB = group.pushSlice(newSliceNamed("b", 1, 4));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(2, subRows.length);
    assertEquals(1, subRows[0].length);
    assertEquals(1, subRows[1].length);
    assertArrayEquals([sA], subRows[0]);
    assertArrayEquals([sB], subRows[1]);
  }

  tests.testSubRowBuilderInstantEvents = function() {
    var group = new TimelineSliceGroup();
    var sA = group.pushSlice(newSliceNamed("a", 1, 0));
    var sB = group.pushSlice(newSliceNamed("b", 2, 0));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(1, subRows.length);
    assertEquals(2, subRows[0].length);
    assertArrayEquals([sA, sB], subRows[0]);
  }

  tests.testSubRowBuilderTwoInstantEvents = function() {
    var group = new TimelineSliceGroup();
    var sA = group.pushSlice(newSliceNamed("a", 1, 0));
    var sB = group.pushSlice(newSliceNamed("b", 1, 0));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(2, subRows.length);
    assertArrayEquals([sA], subRows[0]);
    assertArrayEquals([sB], subRows[1]);
  }

  tests.testSubRowBuilderOutOfOrderAddition = function() {
    var group = new TimelineSliceGroup();

    // Pattern being tested:
    // [    a     ][   b   ]
    // Where insertion is done backward.
    var sB = group.pushSlice(newSliceNamed("b", 3, 1));
    var sA = group.pushSlice(newSliceNamed("a", 1, 2));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(1, subRows.length);
    assertEquals(2, subRows[0].length);
    assertArrayEquals([sA, sB], subRows[0]);
  }


  tests.testSubRowBuilderOutOfOrderAddition2 = function() {
    var group = new TimelineSliceGroup();

    // Pattern being tested:
    // [    a     ]
    //   [  b   ]
    // Where insertion is done backward.
    var sB = group.pushSlice(newSliceNamed("b", 3, 1));
    var sA = group.pushSlice(newSliceNamed("a", 1, 5));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(2, subRows.length);
    assertEquals(1, subRows[0].length);
    assertEquals(1, subRows[1].length);
    assertArrayEquals([sA], subRows[0]);
    assertArrayEquals([sB], subRows[1]);
  }

  tests.testSubRowBuilderOnNestedZeroLength = function() {
    var group = new TimelineSliceGroup();

    // Pattern being tested:
    // [    a    ]
    // [  b1 ]  []<- b2 where b2.duration = 0 and b2.end == a.end.
    var sA = group.pushSlice(newSliceNamed("a", 1, 3));
    var sB1 = group.pushSlice(newSliceNamed("b1", 1, 2));
    var sB2 = group.pushSlice(newSliceNamed("b2", 4, 0));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(2, subRows.length);
    assertArrayEquals([sA], subRows[0]);
    assertArrayEquals([sB1, sB2], subRows[1]);
  }

  tests.testSubRowBuilderOnGroup1 = function() {
    var group = new TimelineSliceGroup();

    // Pattern being tested:
    // [    a     ]   [  c   ]
    //   [  b   ]
    var sA = group.pushSlice(newSliceNamed("a", 1, 3));
    var sB = group.pushSlice(newSliceNamed("b", 1.5, 1));
    var sC = group.pushSlice(newSliceNamed("c", 5, 0));

    var track = new TimelineSliceGroupTrack();
    track.group = group;
    var subRows = track.subRows_;

    assertEquals(0, track.badSlices_.length);
    assertEquals(2, subRows.length);
    assertArrayEquals([sA, sC], subRows[0]);
    assertArrayEquals([sB], subRows[1]);
  }

  tests.testSubRowBuilderOnGroup2 = function() {
    var group = new TimelineSliceGroup();

    // Pattern being tested:
    // [    a     ]   [  d   ]
    //   [  b   ]
    //    [ c ]
    var sA = group.pushSlice(newSliceNamed("a", 1, 3));
    var sB = group.pushSlice(newSliceNamed("b", 1.5, 1));
    var sC = group.pushSlice(newSliceNamed("c", 1.75, 0.5));
    var sD = group.pushSlice(newSliceNamed("c", 5, 0.25));

    var track = new TimelineSliceGroupTrack();
    track.group = group;

    var subRows = track.subRows_;
    assertEquals(0, track.badSlices_.length);
    assertEquals(3, subRows.length);
    assertArrayEquals([sA, sD], subRows[0]);
    assertArrayEquals([sB], subRows[1]);
    assertArrayEquals([sC], subRows[2]);
  }

  tests.testTrackFiltering = function() {
    var group = new TimelineSliceGroup();

    var sA = group.pushSlice(newSliceNamed("a", 1, 3));
    var sB = group.pushSlice(newSliceNamed("b", 1.5, 1));

    var track = new TimelineSliceGroupTrack();
    track.group = group;

    assertEquals(2, track.subRows_.length);
    assertTrue(track.visible);

    track.categoryFilter = new tracing.TimelineTitleFilter('x');
    assertFalse(track.visible);

    track.categoryFilter = new tracing.TimelineTitleFilter('a');
    assertTrue(track.visible);
    assertEquals(1, track.subRows_.length);

    track.categoryFilter = new tracing.TimelineTitleFilter('b');
    assertTrue(track.visible);
    assertEquals(1, track.subRows_.length);
  }

  tests.testAsyncSliceGroup_filterSubRows =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    console.log(JSON.stringify(g));
    var track = new TimelineAsyncSliceGroupTrack();
    track.group = g;

    assertEquals(1, track.subRows_.length);
    assertTrue(track.visible);

    track.categoryFilter = new tracing.TimelineTitleFilter('x');
    assertFalse(track.visible);

    track.categoryFilter = new tracing.TimelineTitleFilter('a');
    assertTrue(track.visible);
    assertEquals(1, track.subRows_.length);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_twoNonOverlappingSlices =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(1, 1, t1, t1));
    var track = new TimelineAsyncSliceGroupTrack();
    track.group = g;
    var subRows = track.subRows_;

    assertEquals(1, subRows.length);
    assertEquals(2, subRows[0].length);
    assertEquals(g.slices[0].subSlices[0], subRows[0][0]);
    assertEquals(g.slices[1].subSlices[0], subRows[0][1]);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_twoOverlappingSlices = function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1.5, t1, t1));
    g.updateBounds();
    var track = new TimelineAsyncSliceGroupTrack();
    track.group = g;
    var subRows = track.subRows_;

    assertEquals(2, subRows.length);
    assertEquals(1, subRows[0].length);
    assertEquals(g.slices[0], subRows[0][0]);
    assertEquals(1, subRows[1].length);
    assertEquals(g.slices[1], subRows[1][0]);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_threePartlyOverlappingSlices =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1.5, t1, t1));
    g.slices.push(newAsyncSlice(1, 1.5, t1, t1));
    g.updateBounds();
    var track = new TimelineAsyncSliceGroupTrack();
    track.group = g;
    var subRows = track.subRows_;

    assertEquals(2, subRows.length);
    assertEquals(2, subRows[0].length);
    assertEquals(g.slices[0].subSlices[0], subRows[0][0]);
    assertEquals(g.slices[2].subSlices[0], subRows[0][1]);
    assertEquals(1, subRows[1].length);
    assertEquals(g.slices[1].subSlices[0], subRows[1][0]);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_twoOverlappingSlices = function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1.5, t1, t1));
    g.slices.push(newAsyncSlice(2, 1, t1, t1));
    g.updateBounds();
    var track = new TimelineAsyncSliceGroupTrack();
    track.group = g;
    var subRows = track.subRows_;

    assertEquals(2, subRows.length);
    assertEquals(2, subRows[0].length);
    assertEquals(g.slices[0].subSlices[0], subRows[0][0]);
    assertEquals(g.slices[2].subSlices[0], subRows[0][1]);
    assertEquals(1, subRows[1].length);
    assertEquals(g.slices[1].subSlices[0], subRows[1][0]);
  }

  tests.testAsyncSliceGroup_computeSubGroups_twoThreadSpecificSlices =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var t2 = new TimelineThread(p1, 2);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1, t2, t2));
    var track = new TimelineAsyncSliceGroupTrack();
    track.group = g;
    var subRows = track.subRows_;

    var subGroups = g.computeSubGroups();
    assertEquals(2, subGroups.length);

    assertEquals(g.name, subGroups[0].name);
    assertEquals(1, subGroups[0].slices.length);
    assertEquals(g.slices[0], subGroups[0].slices[0]);

    assertEquals(g.name, subGroups[1].name);
    assertEquals(1, subGroups[1].slices.length);
    assertEquals(g.slices[1], subGroups[1].slices[0]);
  }

  return tests;
});
</script>
</body>
</html>
