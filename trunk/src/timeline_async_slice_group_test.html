<!DOCTYPE HTML>
<html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<head>
<title>TimelineAsyncSliceGroup tests</title>
<script src="base.js"></script>
</head>
<body>
<script>
'use strict';

base.defineModule('timeline_async_slice_group_test')
    .dependsOn('unittest',
               'test_utils',
               'timeline_model')
    .runAllTests(function() {

  var tests = {};

  var TimelineProcess = tracing.TimelineProcess;
  var TimelineThread = tracing.TimelineThread;
  var TimelineModel = tracing.TimelineModel;
  var TimelineAsyncSlice = tracing.TimelineAsyncSlice;
  var TimelineAsyncSliceGroup = tracing.TimelineAsyncSliceGroup;
  var newAsyncSlice = test_utils.newAsyncSlice;

  tests.testAsyncSliceGroupBounds_Empty = function() {
    var g = new TimelineAsyncSliceGroup(name);
    g.updateBounds();
    assertEquals(undefined, g.minTimestamp);
    assertEquals(undefined, g.maxTimestamp);
  }

  tests.testAsyncSliceGroupBounds_Basic = function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.push(newAsyncSlice(0, 1, t1, t1));
    g.push(newAsyncSlice(1, 1.5, t1, t1));
    assertEquals(2, g.length);
    g.updateBounds();
    assertEquals(0, g.minTimestamp);
    assertEquals(2.5, g.maxTimestamp);
  }

  tests.testAsyncSliceGroup_filterSubRows =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));

    assertEquals(1, g.subRows.length);

    g.current_filter = new tracing.TimelineTitleFilter('x');
    assertEquals(0, g.subRows.length);

    g.current_filter = new tracing.TimelineTitleFilter('a');
    assertEquals(1, g.subRows.length);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_twoNonOverlappingSlices =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(1, 1, t1, t1));

    assertEquals(1, g.subRows.length);
    assertEquals(2, g.subRows[0].length);
    assertEquals(g.slices[0].subSlices[0], g.subRows[0][0]);
    assertEquals(g.slices[1].subSlices[0], g.subRows[0][1]);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_twoOverlappingSlices = function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1.5, t1, t1));
    g.updateBounds();

    assertEquals(2, g.subRows.length);
    assertEquals(1, g.subRows[0].length);
    assertEquals(g.slices[0], g.subRows[0][0]);
    assertEquals(1, g.subRows[1].length);
    assertEquals(g.slices[1], g.subRows[1][0]);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_threePartlyOverlappingSlices =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1.5, t1, t1));
    g.slices.push(newAsyncSlice(1, 1.5, t1, t1));
    g.updateBounds();

    assertEquals(2, g.subRows.length);
    assertEquals(2, g.subRows[0].length);
    assertEquals(g.slices[0].subSlices[0], g.subRows[0][0]);
    assertEquals(g.slices[2].subSlices[0], g.subRows[0][1]);
    assertEquals(1, g.subRows[1].length);
    assertEquals(g.slices[1].subSlices[0], g.subRows[1][0]);
  }

  tests.testAsyncSliceGroup_rebuildSubRows_twoOverlappingSlices = function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1.5, t1, t1));
    g.slices.push(newAsyncSlice(2, 1, t1, t1));
    g.updateBounds();

    assertEquals(2, g.subRows.length);
    assertEquals(2, g.subRows[0].length);
    assertEquals(g.slices[0].subSlices[0], g.subRows[0][0]);
    assertEquals(g.slices[2].subSlices[0], g.subRows[0][1]);
    assertEquals(1, g.subRows[1].length);
    assertEquals(g.slices[1].subSlices[0], g.subRows[1][0]);
  }

  tests.testAsyncSliceGroup_computeSubGroups_twoThreadSpecificSlices =
      function() {
    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var t2 = new TimelineThread(p1, 2);
    var g = new TimelineAsyncSliceGroup('a');
    g.slices.push(newAsyncSlice(0, 1, t1, t1));
    g.slices.push(newAsyncSlice(0, 1, t2, t2));

    var subGroups = g.computeSubGroups();
    assertEquals(2, subGroups.length);

    assertEquals(g.name, subGroups[0].name);
    assertEquals(1, subGroups[0].slices.length);
    assertEquals(g.slices[0], subGroups[0].slices[0]);

    assertEquals(g.name, subGroups[1].name);
    assertEquals(1, subGroups[1].slices.length);
    assertEquals(g.slices[1], subGroups[1].slices[0]);
  }

  tests.testAsyncSlice_toJSON = function() {
    var js = [
      '{',
      '  "category" : "",',
      '  "title" : "a",',
      '  "start" : 0,',
      '  "colorId" : 0,',
      '  "didNotFinish" : false,',
      '  "duration" : 1,',
      '  "startThread" : "1:1",',
      '  "endThread" : "1:1",',
      '  "subSlices" : [ {',
      '        "category" : "",',
      '        "title" : "a",',
      '        "start" : 0,',
      '        "colorId" : 0,',
      '        "didNotFinish" : false,',
      '        "duration" : 1,',
      '        "startThread" : "1:1",',
      '        "endThread" : "1:1"',
      '      } ]',
      '}'].join('\n');
    // Modify whitespace of "js" so that string compare with another
    // JSON.stringified version can succeed.
    js = JSON.stringify(JSON.parse(js));

    var p1 = new TimelineProcess(1);
    var t1 = new TimelineThread(p1, 1);
    var s = newAsyncSlice(0, 1, t1, t1);

    assertEquals(js, JSON.stringify(s));
  }

  return tests;
});
</script>
</body>
</html>
